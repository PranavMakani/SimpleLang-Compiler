# SimpleLang Compiler Project

## Project Overview
The SimpleLang Compiler is a project designed to convert SimpleLang code into assembly code for an 8-bit CPU. This project provides a deep dive into the fundamental processes of how programming languages interact with computer hardware. By the end, you'll understand the journey from writing high-level code to generating low-level assembly instructions that a CPU can execute.

## How the Code Works

### Lexer (`lexer.c`)
The lexer is responsible for scanning the SimpleLang source code and breaking it down into tokensâ€”small, meaningful elements like keywords, operators, and identifiers. 

- **Functions and Variables:**
  - `getNextToken()`: This function reads the input code and returns the next token.
  - `Token current_token`: Holds the current token being processed.
  - `input[]`: An array holding the SimpleLang source code.
  - `TOKEN_ASSIGN` and `TOKEN_EQUAL`: Differentiates between the assignment operator (`=`) and the equality operator (`==`).

The lexer takes a line like `x = 5 + 3;` and converts it into tokens: `IDENTIFIER(x)`, `ASSIGN(=)`, `NUMBER(5)`, `PLUS(+)`, `NUMBER(3)`, and `SEMICOLON(;)`.

### Parser (`parser.c`)
The parser receives the tokens from the lexer and constructs an Abstract Syntax Tree (AST). This tree represents the grammatical structure of the source code.

- **Functions and Variables:**
  - `parseExpression()`: Handles parsing expressions like `5 + 3`.
  - `Junc* root`: The root node of the AST, where `Junc` is the structure used to represent tree nodes.
  - `TOKEN_ASSIGN` vs `TOKEN_EQUAL`: Differentiates between assignment and comparison during parsing.
  - `parseStatement()`: Parses statements such as variable assignments or loops.

The AST is crucial because it determines how different parts of the code relate to each other. For instance, `x = 5 + 3;` would result in a tree where `x` is assigned the result of `5 + 3`.

### Code Generator (`codegen.c`)
The code generator traverses the AST and produces the corresponding assembly code. This assembly code is what the CPU will execute.

- **Functions and Variables:**
  - `generateCode(Junc* node)`: Recursively walks the AST and generates the corresponding assembly instructions.
  - `emit()`: Outputs assembly instructions.
  - `InstructionSet opcodes`: A mapping of operations (like `ADD`, `SUB`) to their corresponding assembly codes.

If the AST node represents an addition operation, the code generator will output an `ADD` instruction, like `ADD R1, R2`, where `R1` and `R2` are registers holding the numbers to be added.

### Main Program (`main.c`)
The main program coordinates the entire compilation process. It reads the SimpleLang source code, runs it through the lexer and parser, and then generates the final assembly code.

- **Functions and Variables:**
  - `main()`: The entry point of the compiler, orchestrating the lexical analysis, parsing, and code generation.
  - `inputFile`: A file pointer to the SimpleLang source code.
  - `char assemblyCode[]`: An array that stores the generated assembly code.

After processing, the final assembly code is printed out, ready to be executed on an 8-bit CPU simulator.

## How to Get Started

### Set Up the Simulator
First, you'll need to set up an 8-bit CPU simulator on your computer. This will allow you to run the assembly code generated by the compiler.

### Compile and Run
After setting up the simulator:
1. Compile the SimpleLang compiler using a C compiler.
2. Run the compiler with a SimpleLang source file as input.
3. The output will be assembly code, which can then run on simulator.

